<!DOCTYPE html>
<html>
    <head>
        <title>Engineering Standards : Cloud Native Tenants</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">Engineering Standards</a></span>
                            </li>
                                                    <li>
                                <span><a href="33470365.html">Engineering Standards &amp; Best Practices</a></span>
                            </li>
                                                    <li>
                                <span><a href="Services-Guidance%2C-Design%2C-and-Review-Criteria_127664218.html">Services Guidance, Design, and Review Criteria</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            Engineering Standards : Cloud Native Tenants
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
        
            Created by <span class='author'> Jerry Shaughnessy</span>, last modified on Oct 25, 2017
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <p><span class="TextRun SCXW259199051" style="color: rgb(0,0,0);"><span class="NormalTextRun SCXW259199051" style="color: rgb(0,0,0);">This section describes the core tenets that define how cloud-native applications are designed and built. <span> </span></span></span><span class="TextRun SCXW259199051" style="color: rgb(0,0,0);"><span class="NormalTextRun SCXW259199051" style="color: rgb(0,0,0);">Moving to the cloud is a natural evolution of focusing on software, and cloud-native application architectures are at the center of how companies<span> </span></span></span><span class="TextRun SCXW259199051" style="color: rgb(0,0,0);"><span class="NormalTextRun SCXW259199051" style="color: rgb(0,0,0);">address its unique challenges</span></span><span class="TextRun SCXW259199051" style="color: rgb(0,0,0);"><span class="NormalTextRun SCXW259199051" style="color: rgb(0,0,0);">. By cloud, we mean any computing environment in which computing, networking, and storage resources can be provisioned and released elastically in an on-demand, self-service manner. This definition includes both public cloud infrastructure (such as Amazon Web Services, Google Cloud, or Microsoft Azure) and private cloud infrastructure (such as VMware vSphere or OpenStack).</span></span><span class="EOP SCXW259199051" style="color: rgb(0,0,0);"> </span></p><p><br/></p><h2 id="CloudNativeTenants-Speed"><span class="EOP SCXW259199051" style="color: rgb(0,0,0);">Speed</span></h2><p><span><span>Businesses that are able to innovate, experiment, and deliver software-based solutions quickly are outcompeting those that follow more traditional delivery methods.  Currently, here at Placester, the time it takes to provision new application environments and deploy new versions of software is typically measured in days or weeks.  This lack of speed severely limits the risk that can be taken on by any one release, because the cost of making and fixing a mistake is also measured on that same timescale.  Consider, as an example, the number of people swarmed onto the 9.0 release bug fixes and the negative industry feedback and the total man-hour cost and lost reputation and market story involved.  Similar problems occur in each release, although to a lesser extent, where we take on aggressive features.</span></span><span> </span></p><p><span><span>Internet companies as Google, Microsoft, Amazon, etc. are often cited for their practice of deploying hundreds of times per day.    Frequent deployments are important because if you deploy at a high frequency, you can recover from mistakes almost instantly.  If you can recover from mistakes almost instantly, you can take on more risk and more features – which just might turn into our next competitive advantage.</span></span><span> </span></p><p><span><span>It is the elastic and self-service nature of cloud-based infrastructure that lends itself to this way of working.  Provisioning a new application environment can be made as simple as a single call to a cloud service API.  Deploying code to that new environment via another API call adds even more speed.  Ultimately, this means that we could deploy a fix or change in minutes or seconds.</span></span><span> </span></p><h2 id="CloudNativeTenants-Safety"><span>Safety</span></h2><p><span><span>Cloud native application architectures need to fully balance moving and deploying rapidly with stability, availability, and durability.  </span></span><span> </span></p><p><span><span>As already mentioned, cloud-native application architectures enable us to rapidly recover from mistakes.  To date, none of our efforts has provided a consistently measureable improvement in the number of defects that make it into production – in fact, many of the efforts in this area, things like<span> </span></span></span><span><span>exhaustive documentation, architectural review efforts, and lengthy regression testing cycles all actually get in the way of the speed that we would like to achieve.  </span></span><span> </span></p><p><span><span>How do we go fast and safe?</span></span><span> </span></p><h3 style="margin-left: 30.0px;" id="CloudNativeTenants-Visibility(Monitoring,AuditingandAlerts)"><span style="margin-left: 0.0px;">Visibility (<strong><em>Monitoring, Auditing and Alerts)</em></strong></span></h3><p style="margin-left: 30.0px;"><span style="margin-left: 0.0px;"><span class="TextRun SCXW61769699" style="color: rgb(0,0,0);"><span class="NormalTextRun SCXW61769699" style="color: rgb(0,0,0);">Our architectures must provide us with the tools necessary to see failure when it happens.  We need the ability to measure key system metrics, establish profiles for “what is normal,” detect deviations from the norm (including rate of change), and identify the components contributing to those deviations.  Feature-rich metrics, monitoring, alerting, and data visualization frameworks and tools are at the heart of all cloud-native architectures.</span></span><span class="EOP SCXW61769699" style="color: rgb(0,0,0);"> </span></span></p><h3 style="margin-left: 30.0px;" id="CloudNativeTenants-FaultIsolation(ReducingBlastRadius)"><span style="margin-left: 0.0px;"><span class="EOP SCXW61769699" style="color: rgb(0,0,0);">Fault Isolation (<strong><em>Reducing Blast Radius)</em></strong></span></span></h3><p style="margin-left: 30.0px;"><span style="margin-left: 0.0px;"><span class="EOP SCXW61769699" style="color: rgb(0,0,0);margin-left: 0.0px;"><span class="TextRun SCXW167041014" style="color: rgb(0,0,0);"><span class="NormalTextRun SCXW167041014" style="color: rgb(0,0,0);">In order to limit risk associated with a failure, we need to limit the scope of components or features that could be affected by a failure. If no one could use Placester's Suite of products every time a feature like CRM went down, that would be disastrous.  Our current architectures often exhibit just this type of failure mode.  By composing systems in Placester from microservices (the most often employed approach in cloud-native applications), we can limit the scope of a failure in any one microservice to just that microservice if combined with fault tolerance.</span></span><span class="EOP SCXW167041014" style="color: rgb(0,0,0);"> </span></span></span></p><h3 style="margin-left: 30.0px;" id="CloudNativeTenants-FaultTolerance(SurvivingtheShock)"><span style="margin-left: 0.0px;"><span class="EOP SCXW61769699" style="color: rgb(0,0,0);margin-left: 0.0px;"><span class="EOP SCXW167041014" style="color: rgb(0,0,0);">Fault Tolerance <em>(Surviving the Shock)</em></span></span></span></h3><p style="margin-left: 30.0px;"><span style="margin-left: 0.0px;"><span class="EOP SCXW61769699" style="color: rgb(0,0,0);margin-left: 0.0px;"><span class="EOP SCXW167041014" style="color: rgb(0,0,0);margin-left: 0.0px;"><span class="TextRun SCXW189622800" style="color: rgb(0,0,0);"><span class="NormalTextRun SCXW189622800" style="color: rgb(0,0,0);">It is not enough to decompose a system into independently deployable components; we must also ensure that a failure in one of those components cannot cause a cascading failure across its possibly many dependencies.  While there are many patterns that deal with this, the most popular is<span> </span></span></span><span class="TextRun SCXW189622800" style="color: rgb(0,0,0);"><span class="NormalTextRun SCXW189622800" style="color: rgb(0,0,0);">circuit breaker</span></span><span class="TextRun SCXW189622800" style="color: rgb(0,0,0);"><span class="NormalTextRun SCXW189622800" style="color: rgb(0,0,0);"><span> </span>approach.  A software circuit breaker is analogous to an electrical circuit breaker: it prevents a cascading failure by opening the path between the component it protects and the remainder of the failing system.  It also typically addresses a graceful fallback behavior while the circuit breaker is open.</span></span><span class="EOP SCXW189622800" style="color: rgb(0,0,0);"> </span></span></span></span></p><h3 style="margin-left: 30.0px;" id="CloudNativeTenants-AutomatedRecovery(Healing)"><span style="margin-left: 0.0px;"><span class="EOP SCXW61769699" style="color: rgb(0,0,0);margin-left: 0.0px;"><span class="EOP SCXW167041014" style="color: rgb(0,0,0);margin-left: 0.0px;"><span class="EOP SCXW189622800" style="color: rgb(0,0,0);">Automated Recovery <em>(Healing)</em></span></span></span></span></h3><p style="margin-left: 30.0px;"><span style="margin-left: 0.0px;"><span class="EOP SCXW61769699" style="color: rgb(0,0,0);margin-left: 0.0px;"><span class="EOP SCXW167041014" style="color: rgb(0,0,0);margin-left: 0.0px;"><span class="EOP SCXW189622800" style="color: rgb(0,0,0);margin-left: 0.0px;"><span class="TextRun SCXW248131588" style="color: rgb(0,0,0);"><span class="NormalTextRun SCXW248131588" style="color: rgb(0,0,0);">With visibility, fault isolation, and fault tolerance, we have the tools we need to identify failure, recover from failure, and provide a reasonable level of service to our customers while we’re engaging in the process of identification and recovery.  Some failures are easy to identify; they present the same easily identifiable pattern every time they occur.  Take, for example, a service health check, which typically has a binary answer: healthy or unhealthy, up or down.  Many times we will take the same course of action every time we encounter failures like these.  In the case of a failed health check, we’ll often simply restart or redeploy the service in question.  Cloud-native application architectures don’t wait for manual intervention in these situations.  Instead, they employ automated detection and recovery.</span></span></span></span></span></span></p><h2 id="CloudNativeTenants-Scale"><span style="margin-left: 0.0px;"><span class="EOP SCXW61769699" style="color: rgb(0,0,0);margin-left: 0.0px;"><span class="EOP SCXW167041014" style="color: rgb(0,0,0);margin-left: 0.0px;"><span class="EOP SCXW189622800" style="color: rgb(0,0,0);margin-left: 0.0px;"><span class="TextRun SCXW248131588" style="color: rgb(0,0,0);"><span class="NormalTextRun SCXW248131588" style="color: rgb(0,0,0);margin-left: 0.0px;">Scale</span></span></span></span></span></span></h2><p><span><span>As demand increases, we need to scale out capacity to automatically service the demand.  Here at Placester, in the past, we typically handled more demand by scaling vertically: we had to buy larger servers.  This accomplished the goals of scaling; but, very slowly and at great expense.  The next iteration of scaling was to increase the number of servers and by installing services on every machine. The reality in either case is that this leads to capacity planning based on peak usage forecasting.  Hardware is purchased and allocated based on the most computing power that will be needed for these<span> </span></span></span><span><span>peak times.  Many times, despite our best efforts, we get this wrong and still blow through available capacity during large activity periods.  Typically, however, clients are saddled with tens and in some cases scores of servers with mostly idle CPU’s – resulting in poor utilization metrics and high relative cost per user.</span></span><span> </span></p><p><span><span>There are basically two strategies that companies use to approach this problem:</span></span><span> </span></p><ul><li><span><span>Rather than scaling up, tackle scaling as a horizontal issue by spreading instances across larger number of commodity machines.  These machines are easier to acquire and deploy rather quickly.</span></span><span> </span></li><li><span><span>Poor utilization of existing larger servers was improved by virtualizing several smaller servers in the same footprint and deploying multiple isolated workloads to them.</span></span><span> </span></li></ul><p><span><span>In the cloud, these two approaches converge.  The virtualization effort is delegated to the cloud provider (or cloud infrastructure) and the developer focused on horizontal scale of applications across large numbers of cloud server instances.  With the recent shift by all cloud providers in moving from virtual servers to containers as the unit of deployment, the door is opened to greater innovation and cost saving strategies.  Companies addressing software design with these in environments require a much lower capital investment, and provisioning via API not only improves the speed of deployment, but also maximizes the speed with which we can respond to changes in demand.</span></span><span> </span></p><p><span><span>Additionally, another hallmark of cloud-native application architectures is the externalization of state to in-memory data grids, caches, and persistent object stores, while keeping the application or service itself essentially stateless.  Stateless applications can be quickly created and destroyed, as well as attached to and detached from external state managers, enhancing the speed with which the system can respond to changes in demand</span></span><span> </span></p><p><span><span>The biggest challenge is that these benefits come with an inherent cost.  Applications must be architected differently for horizontal rather than vertical scaling.  The elastic nature of the cloud demands ephemerality.</span></span></p><p><br/></p>
                    </div>

                    
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Oct 29, 2017 01:41</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
