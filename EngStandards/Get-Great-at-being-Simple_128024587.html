<!DOCTYPE html>
<html>
    <head>
        <title>Engineering Standards : Get Great at being Simple</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">Engineering Standards</a></span>
                            </li>
                                                    <li>
                                <span><a href="33470365.html">Engineering Standards &amp; Best Practices</a></span>
                            </li>
                                                    <li>
                                <span><a href="Engineering-Principles-Explained_128122895.html">Engineering Principles Explained</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            Engineering Standards : Get Great at being Simple
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
        
            Created by <span class='author'> Jerry Shaughnessy</span>, last modified on Oct 25, 2017
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <p><span>Every engineering team member is responsible for quality software, and by making everyone responsible for quality software, all team members must be able to prove that their work on the software is moving the finished product into the hands of our customers and adding value. All team members are accountable for quality throughout the software lifecycle.</span></p><p><span>How do we address quality? By focusing on being simple. From deciding what we want, down to programming it and getting it right, software development can be very complex - yet we do best when we can find simplicity in how we work. </span></p><p><span>Simple is good.  Simple allows us to focus on delivering the one thing that will totally delight our customers. When we do one thing well, rather than several things as well as we can, the outcome will always be better. If we deliver on those tasks that will make a big difference, imagine how much more productive we can be. Simple allows us to focus our energy.</span></p><p><span>Simple isn’t easy. It takes hard work to find the one thing that you need to focus on: trying to work out what the problem you are trying to solve is.  It’s too easy to say “...and then we can add these additional features too.”  It’s hard not to continually tweak a good idea until it becomes confused.  Simple is all about bringing clarity to our work.</span></p><p><span>Simple lets us be agile.  Keeping things simple allows us to back up, learn from our experiences, but not be so committed that we can only continue in one direction. Simple enables us to adapt.</span></p><p><br/></p><p><span><span style="color: rgb(255,0,0);"><em><strong>Placester’s six required principles for effective software development</strong></em></span> provide a powerful way to manage complexity and allow us to keep things simple:</span></p><p><br/></p><div class="table-wrap"><table class="relative-table confluenceTable" style="width: 100.0%;"><colgroup><col style="width: 20.8018%;"/><col style="width: 79.1982%;"/></colgroup><tbody><tr><th class="confluenceTh">Principle</th><th class="confluenceTh">Description / Example</th></tr><tr><td class="confluenceTd"><em><strong>Provide Noticeable Value</strong></em></td><td class="confluenceTd"><span>If a tree falls in a forest and nobody's around to hear it, does it make a sound? </span><strong>Every user seeks value and every software developer should make sure to add understandable value to the newly developed solution or to increment such value in an already distributed solution.</strong><span> Every time developers get their hands on a project, they must acknowledge the fact that someone else will use and take advantage of what is being produced. Therefore, they’re expected to design not only an industry-responsive and industrially strong software, but one where the value of which is recognizable and easily ostensible. There are always third-parties that will have to understand what they have been given. Code with the know-how of a software developer but with an eye or expectations of a user.</span></td></tr><tr><td class="confluenceTd"><em><strong>D R Y</strong></em></td><td class="confluenceTd"><span>DRY, (Don’t Repeat Yourself) is vital to understand.  It’s </span><strong>the principle based on the strategic approach to “divide and conquer.”</strong><span> Initially, the complexity of large software projects can be really overwhelming. Because of their complexity, such projects may take too much time, resources and efforts. In order to manage this type of situations, a good strategy would be to try to shrink the complexity by dividing the workload or the system into smaller subsystems and components. </span><span>As engineers divide systems into components, and, further, components into subcomponents, you will arrive at a level, where the complexity is reduced to a single responsibility.</span></td></tr><tr><td class="confluenceTd"><em><strong>K I S S</strong></em></td><td class="confluenceTd"><span>Keep it Simple, Stupid (KISS). Software works best when it’s made simply. To interpret it differently, KISS indicates that the simpler the system is, the easier it operates. </span><strong>And here, simplicity may well be understood as a software which is more easily manageable and less error-prone</strong><span>. Simplicity doesn’t mean a  lack of internal features. These shouldn’t be neglected in the name of simplicity - the most well-crafted and simple designs simultaneously discard any lavish “decoration”, require a lot of work, knowledge and craftsmanship.</span></td></tr><tr><td class="confluenceTd"><em><strong>You Aren't Gonna Need It</strong></em></td><td class="confluenceTd"><span>YAGNI emerged as a cornerstone to Extreme Programming. The principle says, </span><strong>“Always implement things when you actually need them, never when you just foresee that you may need them.”</strong><span> Coders should create code only when such code is required. This doesn’t mean you shouldn’t think about future use cases and ensure the system is flexible and capable enough to accommodate them--they just shouldn’t be coded.</span></td></tr><tr><td class="confluenceTd"><em><strong>S O L I D</strong></em></td><td class="confluenceTd"><p><span>K</span><span>eep SOLID principles in mind when building software:</span></p><p style="margin-left: 60.0px;"><strong><strong>S - Single-Responsibility Principle</strong><span>: a class should have one reason to change, it should have only one job.</span></strong></p><p style="margin-left: 60.0px;"><strong>O - Open-Closed Principle</strong><span>: objects or entities should be open for extension, but closed for modification.</span></p><p style="margin-left: 60.0px;"><strong><strong>L -  Liskov Substitution Principle</strong><span>: every subclass/derived class should be substitutable for their base/parent class.</span></strong></p><p style="margin-left: 60.0px;"><strong>I -   Interface Segregation Principle</strong><span>: a client should never be forced to implement an interface that it doesn’t use or clients shouldn’t be forced to depend on methods they do not use.</span></p><p style="margin-left: 60.0px;"><strong>D - Dependency Inversion Principle</strong><span>: entities must depend on abstractions not on concretions. Essentially, a high level module must not depend on a low level module, but they should depend on abstractions.</span></p></td></tr><tr><td class="confluenceTd"><em><strong>Think</strong></em></td><td class="confluenceTd"><span>Undoubtedly this is placed among the key principles behind building stable and effective software. </span><strong>Thinking clearly, rationally and logically is essential when developing solutions</strong><span>. When a developer is reasoning and looking at things not only objectively but carefully, then this person is more likely to develop clean and effective software which can become the central measure for progress.</span></td></tr></tbody></table></div><p style="margin-left: 60.0px;"><br/></p>
                    </div>

                    
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Oct 29, 2017 01:41</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
